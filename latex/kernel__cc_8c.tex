\hypertarget{kernel__cc_8c}{}\doxysection{kernel\+\_\+cc.\+c File Reference}
\label{kernel__cc_8c}\index{kernel\_cc.c@{kernel\_cc.c}}


The implementation for concurrency control .  


{\ttfamily \#include $<$assert.\+h$>$}\newline
{\ttfamily \#include \char`\"{}kernel\+\_\+sched.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}kernel\+\_\+proc.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}kernel\+\_\+cc.\+h\char`\"{}}\newline
Include dependency graph for kernel\+\_\+cc.\+c\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{kernel__cc_8c__incl}
\end{center}
\end{figure}
\doxysubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{kernel__cc_8c_a146046d778f29cb1d176fcbd4d066733}\label{kernel__cc_8c_a146046d778f29cb1d176fcbd4d066733}} 
\#define {\bfseries M\+U\+T\+E\+X\+\_\+\+S\+P\+I\+NS}~1000
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{group__syscalls_ga1140be44df71d39edaf6a7262fb763ca}{Mutex\+\_\+\+Lock}} (\mbox{\hyperlink{group__syscalls_gaef2ec62cae8e0031fd19fc8b91083ade}{Mutex}} $\ast$lock)
\begin{DoxyCompactList}\small\item\em Lock a mutex. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__syscalls_ga0b98d0315d0931d0c28104c36dd559c9}{Mutex\+\_\+\+Unlock}} (\mbox{\hyperlink{group__syscalls_gaef2ec62cae8e0031fd19fc8b91083ade}{Mutex}} $\ast$lock)
\begin{DoxyCompactList}\small\item\em Unlock a mutex that you locked. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{group__syscalls_ga970dca2210b3f2ec8aedab7f542a9bf4}{Cond\+\_\+\+Wait}} (\mbox{\hyperlink{group__syscalls_gaef2ec62cae8e0031fd19fc8b91083ade}{Mutex}} $\ast$mutex, \mbox{\hyperlink{structCondVar}{Cond\+Var}} $\ast$cv)
\begin{DoxyCompactList}\small\item\em Wait on a condition variable. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{group__syscalls_ga4e955b769339be9ea6a0c1bd4151c48f}{Cond\+\_\+\+Timed\+Wait}} (\mbox{\hyperlink{group__syscalls_gaef2ec62cae8e0031fd19fc8b91083ade}{Mutex}} $\ast$mutex, \mbox{\hyperlink{structCondVar}{Cond\+Var}} $\ast$cv, \mbox{\hyperlink{group__syscalls_gaf412159e5cef839836a5e7b19ee75d1c}{timeout\+\_\+t}} timeout)
\begin{DoxyCompactList}\small\item\em Wait on a condition variable. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__syscalls_ga43f64f8be273d2fe77d7de5f4b81e22d}{Cond\+\_\+\+Signal}} (\mbox{\hyperlink{structCondVar}{Cond\+Var}} $\ast$cv)
\begin{DoxyCompactList}\small\item\em Signal a condition variable. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__syscalls_ga8196aa2a48cad90742f254cc3b8fd351}{Cond\+\_\+\+Broadcast}} (\mbox{\hyperlink{structCondVar}{Cond\+Var}} $\ast$cv)
\begin{DoxyCompactList}\small\item\em Notify all threads waiting at a condition variable. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{kernel__cc_8c_a6121802a0b64aae83288f60bf8a76834}{set\+\_\+core\+\_\+preemption}} (int preempt)
\begin{DoxyCompactList}\small\item\em Set the preemption status for the current thread. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{kernel__cc_8c_ac3fd575c0f82fd75f8e7305be1107e2c}{get\+\_\+core\+\_\+preemption}} ()
\begin{DoxyCompactList}\small\item\em Get the current preemption status. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{kernel__cc_8c_a64cbb83e8857ffaf703722363ac94f05}\label{kernel__cc_8c_a64cbb83e8857ffaf703722363ac94f05}} 
void \mbox{\hyperlink{kernel__cc_8c_a64cbb83e8857ffaf703722363ac94f05}{kernel\+\_\+lock}} ()
\begin{DoxyCompactList}\small\item\em Lock the kernel. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{kernel__cc_8c_a8ca062a9a1c570f34398bd177cb96e58}\label{kernel__cc_8c_a8ca062a9a1c570f34398bd177cb96e58}} 
void \mbox{\hyperlink{kernel__cc_8c_a8ca062a9a1c570f34398bd177cb96e58}{kernel\+\_\+unlock}} ()
\begin{DoxyCompactList}\small\item\em Unlock the kernel. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{kernel__cc_8c_a1fad5a21e5010939e1e0ad711192bc6c}{kernel\+\_\+wait\+\_\+wchan}} (\mbox{\hyperlink{structCondVar}{Cond\+Var}} $\ast$cv, enum \mbox{\hyperlink{group__scheduler_gaad787d8d80312ffca3c0f197b3a25fbe}{S\+C\+H\+E\+D\+\_\+\+C\+A\+U\+SE}} cause, const char $\ast$wchan\+\_\+name, \mbox{\hyperlink{bios_8h_ae7291e5cd742fb9bc6d4aaa0d51bd0ee}{Timer\+Duration}} timeout)
\begin{DoxyCompactList}\small\item\em Wait on a condition variable using the kernel lock. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{kernel__cc_8c_a167cdb3f2a2285becf553405210eb08a}{kernel\+\_\+signal}} (\mbox{\hyperlink{structCondVar}{Cond\+Var}} $\ast$cv)
\begin{DoxyCompactList}\small\item\em Signal a kernel condition to one waiter. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{kernel__cc_8c_a6ab8c1febc779de0c176d4e8a101ec5b}\label{kernel__cc_8c_a6ab8c1febc779de0c176d4e8a101ec5b}} 
void \mbox{\hyperlink{kernel__cc_8c_a6ab8c1febc779de0c176d4e8a101ec5b}{kernel\+\_\+broadcast}} (\mbox{\hyperlink{structCondVar}{Cond\+Var}} $\ast$cv)
\begin{DoxyCompactList}\small\item\em Signal a kernel condition to all waiters. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{kernel__cc_8c_aeafd158aa175ab53b85bc55dc4bbd962}{kernel\+\_\+sleep}} (\mbox{\hyperlink{group__scheduler_ga6c969c169777f82c104cf73e501df70f}{Thread\+\_\+state}} newstate, enum \mbox{\hyperlink{group__scheduler_gaad787d8d80312ffca3c0f197b3a25fbe}{S\+C\+H\+E\+D\+\_\+\+C\+A\+U\+SE}} cause)
\begin{DoxyCompactList}\small\item\em Put thread to sleep, unlocking the kernel. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
The implementation for concurrency control . 

Locks for scheduler and device drivers. Because we support multiple cores, we need to avoid race conditions with an interrupt handler on the same core, and also to avoid race conditions between cores. 

\doxysubsection{Function Documentation}
\mbox{\Hypertarget{kernel__cc_8c_ac3fd575c0f82fd75f8e7305be1107e2c}\label{kernel__cc_8c_ac3fd575c0f82fd75f8e7305be1107e2c}} 
\index{kernel\_cc.c@{kernel\_cc.c}!get\_core\_preemption@{get\_core\_preemption}}
\index{get\_core\_preemption@{get\_core\_preemption}!kernel\_cc.c@{kernel\_cc.c}}
\doxysubsubsection{\texorpdfstring{get\_core\_preemption()}{get\_core\_preemption()}}
{\footnotesize\ttfamily int get\+\_\+core\+\_\+preemption (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Get the current preemption status. 

\begin{DoxyReturn}{Returns}
the current preemption status for this core, 0 means no preemption and 1 means preemption. 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{kernel__cc_8h_a6121802a0b64aae83288f60bf8a76834}{set\+\_\+core\+\_\+preemption}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{kernel__cc_8c_a167cdb3f2a2285becf553405210eb08a}\label{kernel__cc_8c_a167cdb3f2a2285becf553405210eb08a}} 
\index{kernel\_cc.c@{kernel\_cc.c}!kernel\_signal@{kernel\_signal}}
\index{kernel\_signal@{kernel\_signal}!kernel\_cc.c@{kernel\_cc.c}}
\doxysubsubsection{\texorpdfstring{kernel\_signal()}{kernel\_signal()}}
{\footnotesize\ttfamily void kernel\+\_\+signal (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structCondVar}{Cond\+Var}} $\ast$}]{cv }\end{DoxyParamCaption})}



Signal a kernel condition to one waiter. 

This call must be made \mbox{\Hypertarget{kernel__cc_8c_aeafd158aa175ab53b85bc55dc4bbd962}\label{kernel__cc_8c_aeafd158aa175ab53b85bc55dc4bbd962}} 
\index{kernel\_cc.c@{kernel\_cc.c}!kernel\_sleep@{kernel\_sleep}}
\index{kernel\_sleep@{kernel\_sleep}!kernel\_cc.c@{kernel\_cc.c}}
\doxysubsubsection{\texorpdfstring{kernel\_sleep()}{kernel\_sleep()}}
{\footnotesize\ttfamily void kernel\+\_\+sleep (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__scheduler_ga6c969c169777f82c104cf73e501df70f}{Thread\+\_\+state}}}]{state,  }\item[{enum \mbox{\hyperlink{group__scheduler_gaad787d8d80312ffca3c0f197b3a25fbe}{S\+C\+H\+E\+D\+\_\+\+C\+A\+U\+SE}}}]{cause }\end{DoxyParamCaption})}



Put thread to sleep, unlocking the kernel. 

System calls should call this function instead of {\ttfamily sleep\+\_\+releasing}, as the kernel lock is not a mutex. \mbox{\Hypertarget{kernel__cc_8c_a1fad5a21e5010939e1e0ad711192bc6c}\label{kernel__cc_8c_a1fad5a21e5010939e1e0ad711192bc6c}} 
\index{kernel\_cc.c@{kernel\_cc.c}!kernel\_wait\_wchan@{kernel\_wait\_wchan}}
\index{kernel\_wait\_wchan@{kernel\_wait\_wchan}!kernel\_cc.c@{kernel\_cc.c}}
\doxysubsubsection{\texorpdfstring{kernel\_wait\_wchan()}{kernel\_wait\_wchan()}}
{\footnotesize\ttfamily int kernel\+\_\+wait\+\_\+wchan (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structCondVar}{Cond\+Var}} $\ast$}]{cv,  }\item[{enum \mbox{\hyperlink{group__scheduler_gaad787d8d80312ffca3c0f197b3a25fbe}{S\+C\+H\+E\+D\+\_\+\+C\+A\+U\+SE}}}]{cause,  }\item[{const char $\ast$}]{wchan,  }\item[{\mbox{\hyperlink{bios_8h_ae7291e5cd742fb9bc6d4aaa0d51bd0ee}{Timer\+Duration}}}]{timeout }\end{DoxyParamCaption})}



Wait on a condition variable using the kernel lock. 

\begin{DoxyReturn}{Returns}
1 if signalled, 0 if not 
\end{DoxyReturn}
\mbox{\Hypertarget{kernel__cc_8c_a6121802a0b64aae83288f60bf8a76834}\label{kernel__cc_8c_a6121802a0b64aae83288f60bf8a76834}} 
\index{kernel\_cc.c@{kernel\_cc.c}!set\_core\_preemption@{set\_core\_preemption}}
\index{set\_core\_preemption@{set\_core\_preemption}!kernel\_cc.c@{kernel\_cc.c}}
\doxysubsubsection{\texorpdfstring{set\_core\_preemption()}{set\_core\_preemption()}}
{\footnotesize\ttfamily int set\+\_\+core\+\_\+preemption (\begin{DoxyParamCaption}\item[{int}]{preempt }\end{DoxyParamCaption})}



Set the preemption status for the current thread. 

Depending on the value of the argument, this function will set preemption on or off. Preemption is disabled by disabling interrupts. This function is usually called via the convenience macros {\ttfamily preempt\+\_\+on} and {\ttfamily preempt\+\_\+off}. A typical non-\/preemptive section is declared as 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{int} preempt = \mbox{\hyperlink{kernel__cc_8h_af936bcf607a61848cfea21c119f30905}{preempt\_off}};}
\DoxyCodeLine{..}
\DoxyCodeLine{    \textcolor{comment}{// do stuff without preemption }}
\DoxyCodeLine{...}
\DoxyCodeLine{if(preempt) \mbox{\hyperlink{kernel__cc_8h_ac8efed506a60c7c6f02514e878a4004b}{preempt\_on}};}
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em preempt} & the new preemption status \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the previous preemption status, where 0 means that preemption was previously off, and 1 means that it was on.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{kernel__cc_8h_af936bcf607a61848cfea21c119f30905}{preempt\+\_\+off}} 

\mbox{\hyperlink{kernel__cc_8h_ac8efed506a60c7c6f02514e878a4004b}{preempt\+\_\+on}} 
\end{DoxySeeAlso}
